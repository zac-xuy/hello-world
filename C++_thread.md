this_thread::yield() 放弃当前线程的时间片，效率依赖底层实现，可能效率并不高。<br>

thread.join()等待thread对象函数执行结束<br>


detach调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的std::thread对象失去对目标线程的关联，无法再通过std::thread对象取得该线程的控制权。当线程主函数执行完之后，线程就结束了，运行时库负责清理与该线程相关的资源。<br>

在 《UNIX 网络编程》卷一 第 537 页，有这么一句话：<br>
如果进程的main函数返回或者任何线程调用了 exit， 整个进程就终止，其中包括它的任何线程。
